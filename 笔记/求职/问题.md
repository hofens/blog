https://juejin.cn/post/7267737437953720359?searchId=202404241136239F7015FFCE2263743379
### String s = new String("xxx");创建了几个 String 对象?
首先代码 `String s = new String("xxx")` 中包含关键字 `new`, 我们都知道此关键字是创建类的实例对象。JVM 在运行期执行 new 指令因此这会在堆中创建一个 String 对象。

其次，在String的构造方法中传递了"xxx"字符串，此处的"xxx"是一个字符串常量。JVM会首先从字符串常量池中尝试获取其对应的引用。如果不存在，则会在堆中创建"xxx"的字符串对象，并将其引用保存到字符串常量池然后返回。

因此，如果`xxx`这个字符串常量不存在，则创建两个String对象；而如果存在则只会创建一个String对象。

### Java 中用\==是否可以判断两个字符串相同
用 equals，但是用\==判断两个字符串是否相同可能会得到 true，因为 JVM 会在字符串常量池中维护一份唯一的字符串实例，导致判断的时候拿到的是同一个对象。\==在 Java 中判断的是内存地址是否相同，所以在这种情况下可能会得到 true。
```
public static void main(String[] args) {
	    String txt = "hello";
		System.out.println(testChar(txt));
		System.out.println(testString(txt));
	}
	
	public static boolean testChar(CharSequence txt) {
	    return txt == "hello";
	}
	
	public static boolean testString(String txt) {
	    return txt == "hello";
	}
	
```

在 Java 中，\==操作符用来比较两个对象的引用是否相等，即它们是否指向 JVM 内存中的同一个位置。
对于基本数据类型 (如 int, char 等) , \==比较的是值是否相等。
但对于对象,包括字符串 (String)对象, \==比较的是对象引用（内存地址）是否相同。字符串 (String)在 Java 中是不可变的, JVM 为了提高性能和减少内存使用,**会在字符串常量池 (StringConstant Pool）中维护一份唯一的字符串实例**。
因此，在某些情况下，使用\==来比较字符串可能会得到你预期的结果，但这并不是一个好的做法。
正确判断字符串相等的方法是使用 equals（)方法。

### 抽象类与接口区别
接口的设计目的，是对类的行为进行约束，类必须实现接口的所有方法，所以即使几个派生类有共同的实现逻辑，也无法复用代码；因此有了抽象类，可以在抽象类中实现公共逻辑从而代码复用或继续交由子类实现。
抽象类可以有 public、protected、default；接口默认是 public 且无其它修饰符


### 重写(Override)与重载(Overload)
重写就是重新写的意思，当父类中的方法对于子类来说不适用或者需要扩展增强时，子类可以对从父类中继承来的方法进行重写。
重载则是在同一个类中，允许存在多个同名方法，只要它们的参数列表不同即可。

### 静态内部类是什么？和非静态内部类的区别是什么？
静态内部类：内部类被 static 声明，则该内部类为静态内部类
非静态内部类能够访问外部类的静态和非静态成员，静态类只能访问外部类的静态成员。
非静态内部类不能脱离外部类被创建，静态内部类可以。
内部静态类不持有外部类的引用

### Java 中在传参数时是将值进行传递，还是传递引用？
Java 的参数传递，不管是基本数据类型还是引用类型的参数，都是按值传递


### finally 中的代码一定会执行吗？try 里有 return，finally 还执行么
finally代码块中的内容一定会得到执行
如果在try中存在return的情况下，会把try中return的值存到栈帧的局部变量表中，然后去执行finally语句块，最后再从局部变量表中取回return的值返回。另外，当try和finally里都有return时，会忽略try的return，而使用finally的return。


### Java异常机制中，异常Exception与错误Error区别
`Throwable` 有两个重要的子类，一个是 Error，另一个则是 Exception。

`Error`是程序不能处理的错误，表示程序中较严重问题。例如OutOfMemoryError。这些错误发生时，JVM一般会选择线程终止。

`Exception` 是程序可以处理的异常。而 Exception 又分为运行时异常（RuntimeException）与非运行时异常。
- 运行异常
    运行时异常，**又称不受检查异常** 。所谓的不受检查，指的是Java编译检查时不会告诉我们有这个异常，需要在运行时候才会暴露出来，比如下标越界，空指针异常等。
- 非运行时异常
    RuntimeException之外的异常我们统称为**非运行时异常**，比如IOException、SQLException，是必须进行处理的异常（**检查异常**） ，如果不处理（throw到上层或者try-catch），程序就不能编译通过 。


### 序列Parcelable,Serializable的区别

序列化 是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。Serializable是Java提供的序列化机制，而 Parcelable则是Android提供的适合于内存中进行传输的序列化方式。

如果只需要在内存中进行数据传输是，序列化应该选择Parcelable，而如果需要存储到设备或者网络传输上应该选择Serializable。这是因为Android不同版本Parcelable数据规则可能不同，所以不推荐使用Parcelable进行数据持久化。


### 为什么 Intent 传递对象为什么需要序列化
在Android中使用Intent传输数据除了基本数据类型之外，对于其他类型对象需要此类型实现了Serializable或者Parcelable序列化接口才能进行传输。
Intent 传输数据本质上是使用 Binder 来完成的。Intent 启动组件需要借助 AMS 完成，因此 `startActivity` 会离开当前应用进程，进入 AMS 所在的 system_server 进程进行跨进程通信。这就意味着传输的对象需要在不同进程之间进行传输。

为了保护不同进程互不干扰，进程隔离让system_server进程无法直接获取应用进程内存中的对象。因此必须通过类似于复制的手段，将应用进程的对象传递给system_server进程，再由system_server进程传递给应用中的`OtherActivity`。

Serializable会利用IO将对象写入到文件中；而Parcelable则会将对象写入到Parcel中，两种方式都可以解决跨进程的数据传递。因此Intent传递的对象需要实现Serializable或者Parcelable序列化。



